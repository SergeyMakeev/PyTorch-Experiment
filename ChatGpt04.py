# generated by chat gpt
import torch
import numpy as np
import matplotlib.pyplot as plt

# Generate data from the sine function
x_np = np.linspace(0, 2*np.pi, 100)
y_np = np.sin(x_np)

# Convert numpy arrays to PyTorch tensors
x = torch.tensor(x_np, dtype=torch.float32).view(-1, 1)
y = torch.tensor(y_np, dtype=torch.float32).view(-1, 1)

# Min-Max scaling
x = (x - x.min()) / (x.max() - x.min())

# Construct the design matrix for an 8th order polynomial
X = torch.cat([x**i for i in range(41)], 1)

# Initialize polynomial coefficients as learnable parameters
weights = torch.randn(41, 1, requires_grad=True)

# Define a learning rate, regularization strength, and an optimizer
learning_rate = 0.05
lambda_reg = 0.001
optimizer = torch.optim.Adam([weights], lr=learning_rate)

# Train the model
num_epochs = 50000
for epoch in range(num_epochs):
    # Compute predictions
    y_pred = X @ weights

    # Compute loss with L2 regularization
    loss = torch.mean((y_pred - y)**2) + lambda_reg * torch.sum(weights**2)

    # Zero gradients, backpropagate, and update weights
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()

    # Print the loss every 5000 epochs
    if epoch % 5000 == 0:
        print(f'Epoch {epoch}/{num_epochs}, Loss: {loss.item()}')

# Evaluate the trained polynomial
y_poly = X @ weights.detach()

# Plot the results
plt.plot(x_np, y_np, label='sin(x)')
plt.plot(x_np, y_poly.numpy(), label='40th order polynomial fit')
plt.legend()
plt.show()
